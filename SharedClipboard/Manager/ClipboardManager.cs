using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Drawing;
using System.Collections.Specialized;
using Quobject.SocketIoClientDotNet.Client;
using Newtonsoft.Json;
using SharedClipboard.Utils;

namespace SharedClipboard.Manager
{
    public class ClipboardManager : IDisposable
    {
        public static string CLIPBOARD_CHANGE = "clipboard_change";
        
        private static IntPtr HWND_MESSAGE = new IntPtr(-3);

        /// <summary>
        /// Adds the given window to the system-maintained clipboard format listener list.
        /// </summary>
        [DllImport("user32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool AddClipboardFormatListener(IntPtr hwnd);

        /// <summary>
        /// Removes the given window from the system-maintained clipboard format listener list.
        /// </summary>
        [DllImport("user32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool RemoveClipboardFormatListener(IntPtr hwnd);

        // See http://msdn.microsoft.com/en-us/library/ms633541%28v=vs.85%29.aspx
        // See http://msdn.microsoft.com/en-us/library/ms649033%28VS.85%29.aspx
        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr SetParent(IntPtr hWndChild, IntPtr hWndNewParent);

        /// <summary>
        /// Specify whether this object is disposed.
        /// </summary>
        bool disposed = false;

        /// <summary>
        /// Sent when the contents of the clipboard have changed.
        /// </summary>
        private const int WM_CLIPBOARDUPDATE = 0x031D;

        /// <summary>
        /// A handle to the window that will receive WM_CLIPBOARDUPDATE messages generated by the
        /// hot key.
        /// </summary>
        public IntPtr Handle { get; private set; }

        /// <summary>
        /// A normal application can use any value between 0x0000 and 0xBFFF as the ID 
        /// but if you are writing a DLL, then you must use GlobalAddAtom to get a 
        /// unique identifier for your hot key. 
        /// </summary>
        public int ID { get; private set; }

        /// <summary>
        /// Raise an event when the clipboard changed.
        /// </summary>
        public event EventHandler ClipboardChanged;

        public Socket socket = null;

        private string sharedText = null;

        public ClipboardManager(IntPtr handle, int id)
        {
            this.Handle = handle;
            this.ID = id;

            //SetParent(Handle, HWND_MESSAGE); do we need this?
            AddClipboardFormatListener(Handle);

            InitializeServerConnection();
        }

        private void InitializeServerConnection() {
            socket = IO.Socket("http://127.0.0.1:3000");
            Console.WriteLine("Connecting to server...");

            socket.On(Socket.EVENT_CONNECT, () =>
            {
                Console.WriteLine("Connected to server.");
            });

            socket.On(CLIPBOARD_CHANGE, (data) =>
            {
                sharedText = (string) data;
            });
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Unregister the clipboard listener.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            // Protect from being called multiple times.
            if (disposed)
            {
                return;
            }

            if (disposing)
            {
                RemoveClipboardFormatListener(Handle);

                if (socket != null)
                {
                    socket.Disconnect();
                }
            }

            disposed = true;
        }

        public void HandleWndProc(ref System.Windows.Forms.Message m)
        {
            if (m.Msg == WM_CLIPBOARDUPDATE)
            {
                //PublishClipboard();

                if (ClipboardChanged != null)
                {
                    ClipboardChanged(this, EventArgs.Empty);
                }
            }
        }

        internal void PublishClipboard()
        {
            IDataObject data = Clipboard.GetDataObject();

            bool emitEvent = false;
            ClipboardData clipboardData = new ClipboardData();

            if (Clipboard.ContainsText())
            {
                string text = Clipboard.GetText();

                clipboardData.Data = text;
                clipboardData.Type = ClipboardDataType.TEXT;
                clipboardData.Id = "1";

                emitEvent = true;
            }
            else if (Clipboard.ContainsImage())
            {
                Bitmap image = (Bitmap) Clipboard.GetImage();

                clipboardData.Data = ImageUtils.ImageToBase64(image);
                clipboardData.Type = ClipboardDataType.IMAGE;
                clipboardData.Id = "1";

                emitEvent = true;
            }
            else if (Clipboard.ContainsFileDropList())
            {
                StringCollection filePaths = Clipboard.GetFileDropList();
                foreach (string filePath in filePaths)
                {
                    Console.WriteLine(filePath);
                }

                //clipboardData.Data = text;
                clipboardData.Type = ClipboardDataType.FILES;
                clipboardData.Id = "1";

                emitEvent = true;
            }

            if (emitEvent)
            {
                socket.Emit(CLIPBOARD_CHANGE, JsonConvert.SerializeObject(clipboardData));
            }
        }

        internal void CopySharedToLocal()
        {
            Clipboard.SetText(sharedText);

            //StringCollection filePaths = new StringCollection();
            //filePaths.Add(@"C:\tmp\tmp.file");
            //filePaths.Add(@"C:\tmp\second_tmp.file");
            //Clipboard.SetFileDropList(filePaths);
        }
    }

}
